---
layout: post
title:  "C语言之 #define 的用法"
date:   2013-10-11 12:00:00
tags:	tech
myTag:	c/c++

---

# C语言之 #define 的用法

在很多公司的面试题目中都会牵涉到`#define`的用法，所以在网上找了一些例子来看，感觉清晰了很多。文章参考自网络上的[C语言之#define用法(终极盘点篇)](http://bbs.csdn.net/topics/300118504)，因为这个帖子已经广为流传，所以只贴出我当时看的网址，作者是谁就无从得知了。

## 1. #define命令剖析

### 1.1 #define的概念

`#define`命令事C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为`宏名`，被定义的字符串称为`替换文本`。

该命令有两种格式：一种是简单的宏定义，另一种事带参数的宏定义。    
(1) 简单的宏定义：

	#define <宏名> <字符串>

例：
	
	#define PI 3.1415926

(2) 带参数的宏定义：

	#define <宏名>(<参数表>) <宏体>

例：

	#define A(x) x

一个标识符被宏定义之后，该标识符就是一个宏名。这时，在程序中出现的是宏名，在该程序被编译前，先将宏名用被定义的字符串替换，这称为`宏替换`，<strong>替换后才进行编译</strong>，宏替换是简单的替换。

### 1.2 宏替换发生的时机

我们知道一个程序要从源码到生成颗执行文件需要执行：预处理、编译、连接。而宏替换就发生在程序的`预处理`阶段。

其中预处理器产生编译器的输出，它实现一下功能：  
(1) 文件包含：将源代码中的#include扩展为文件正文，即把包含的.h文件找到并扩展到#include所在处。  
(2) 条件编译：预处理器根据#if和#ifdef等编译命令及其后的条件，将源代码中的某部份包含或排除在外。  
(3) 宏展开：预处理器将源代码中出现的对宏的引用展开成相应的宏定义，即本文所说的#define的功能，由预处理器完成。`这个阶段所进行的工作只是纯粹的替换与展开，没有任何计算功能。<`
## 2. #define使用中常见问题解析

### 2.1 简单宏定义使用中出现的问题

在简单宏定义的使用中，当替换文本所表示的字符串为一个表达式时，容易产生误用。如：

	#include <stdio.h>
	#definde N 2+2

	int main(){
		int a = N*N;
		printf("%d", a);
		return 0;
	}

输出

	8

(1) 出现问题：该程序的输出为`8`，而并不是看上去的`16`。  
(2) 问题解析：宏展开是在预处理的阶段完成的，这个阶段仅仅把替换文本看作一个字符串，并不会有任何的计算结果，所以本例中仅仅把N替换成2+2，a的结果为2+2*2+2，答案为8。  
(3) 解决方法：将宏定义写成如下形式`#define N (2+2)`，这样子就可以替换成`(2+2)*(2+2)`。

### 2.2 带参数的宏定义出现的问题

考虑下面这个例子，例如我们需要做一个宏替换能求任何数的平方：

	#include<stdio.h>
	#define area(x) x*x

	int main(){
		int y = area(2+2);
		printf("%d", y);
		return 0;
	}

输出
	
	8

(1) 出现问题：参数为2+2, 结果却为8。  
(2) 问题解析：本例中，`2+2`为`area`宏中的参数，应该由它来替换宏定义的`x`，即替换成`2+2*2+2`，依然得到8。如果使用2.1中的方法，把它参数`2+2`括起来，是否又可行呢。

	#define area(x) (x)*(x)

对于`area(2+2)`，替换为`(2+2)*(2+2)`，结果为`16`，可以解决问题，但是仍会产生问题。

考虑`area(2+2)/area(2+2)`。替换会成为`(2+2)*(2+2)/(2+2)*(2+2)`，也并不是我们直观想要实现的除法。解决方法是在整个宏体上再加一个括号，即：

	#define area(x) ((x)*(x))

如果是带参数的宏定义，在整个宏体上再加一个括号是非常必要的。

## 3. 宏定义的好处

既然宏定义这么容易出错，为什么我们还要使用它。

(1) 方便程序修改。  
(2) 提高运行效率。

使用带参数的宏定义可以完成函数调用的功能，却又不用像函数调用一样有所谓的保存现场，恢复现场一说，提高了效率。
