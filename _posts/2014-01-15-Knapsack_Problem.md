---
layout: post
title:  "Knapsack Problem"
date:   2014-01-15 12:00:00
tags:	tech
myTag:	algorithm	

---


# 背包问题


## P01:01背包问题

*问题: 有N件物品和一个容量为V的背包。第i件物品的大小是c[i]，价值是w[i]。`每个物品只有一件`。求解哪些物品装入背包可使总价值最大。*

### 基本思路

每个物品只有一件，只有选择和不选择两种情况，所以这种问题才叫做01背包问题。对于第i件物品是否选择，有f[i][v]表示0~i件物品恰当选择后容量为v的背包的总价值。那么对于第i个物品是不是选择有状态转移方程:

 <center> ***f[i][v] = max{ f[i-1][v], f[i-1][v-c[i]]+w[i] }*** </center>

这个方程表示如果第i件物品不选，那么背包总价值f[i][v]与f[i-1][v]相同；如果第i件物品要选，那么背包总价值应该为f[i-1][v-c[i]]再加上选择第i件的价值w[i]。

伪代码为:

	for i=1...N
		for v=0...V
			if f[i-1][v-c[i]]+w[i] > f[i][v]
				f[i][v] = f[i-1][v-c[i]]+w[i]

### 空间复杂度优化

上述方法的空间和时间复杂度都是O(N\*V)，其中时间复杂度无法再优化，但是空间复杂度可以优化成O(N)。伪代码如下:

	for i=1...N
		for v=V...0
			if f[v-c[i]]+w[i] > f[v]
				f[v] = f[v-c[i]]+w[i]

考虑只要保证f[v] = max{ f[v], f[v-c[i]]+w[i] }中f[v-c[i]]的值确实为f[i][v] = max{ f[i-1][v], f[i-1][v-c[i]]+w[i] }中f[i-1][v-c[i]]即可。因此在更新f[v]时，f[v-c[i]]的值应该还是f[i-1][v-c[i]]，所以v的循环需要逆序。

### 初始化问题

考虑背包问题的问法:

1. 背包能够装满的最大价值
2. 背包能够装的最大价值

如果题目只需要求能够装的最大价值，那么我们可以初始化所有f为0。如果题目要求能够装满的最大价值，初始化所有f为-∞。f为负无穷表示没有一个合法的状态。如果要求背包恰好被装满，则此时只有容量为0的背包可能被价值为0的空状态恰好装满，其它情况下都没有合法解，初始化为-∞；如果背包没有要求恰好装满，那么任意容量的背包都有一个合法解"什么都不装"，这个解的价值为0，所以初始为0。



## P02:完全背包问题

*问题: 有N种物品和一个容量为V的背包。`每种物品有无限件可用`。第i件物品的大小是c[i]，价值是w[i]。求解哪些物品装入背包可使总价值最大。*

### 基本思路

完全背包问题相对于01背包问题不同点只是对于同种物品能够选择的值从{0,1}变到了{0,1,2,...}所以有状态转移方程:

<center> ***f[i][v] = max{ f[i-1][v-k\*c[i]]+k\*w[i] | 0<=k\*c[i]<=v }*** </center>

时间复杂度从01背包问题的O(VN)变成了O(V\*Σ(V/c[i]))。

### 一个简单有效的优化

完全背包问题中如果存在这种情况:并不要求背包恰好装满，若两件物品i和j满足c[i]<=c[j]且w[i]>=w[j]则可以将物品j丢弃，不用考虑。因为在任何情况下，我们都能够将价值低费用高的换成更物美价廉的东西。

### 转为01背包问题

考虑到第i种物品最多可以选择V/c[i]件，我们可以将第i种物品转化为V/c[i]件单独的物品，这样就相当于01背包问题了。

更高效的转化方法可以是将第i件物品拆成费用为c[i]\*2^k，价值为w[i]\*2^k件物品。这样将每种物品拆成了O(log V/c[i])件物品，是一个很大的改进。

### O(VN)的算法

考虑如下伪代码:

	for i=i...N
		for v=0...V
			f[v]=max{f[v], f[v-cost]+weight}

这于01背包问题中使用一维数组的方法相比，不同的仅仅是v的循环是顺序的。因为在01背包问题中，我们需要保证在推导f[v]时，f[v-c[i]]中存的确实为f[i-1][v-c[i]]的值而不是f[i][v-c[i]]的值，所以v的循环需要逆序。而在完全背包问题中，每种物品能够选择无限次，正好需要已经选入第i件物品的结果f[i][v-c[i]]+weight。状态转移方程等价于:

<center> ***f[i][v] = max{ f[i-1][v], f[i][v-c[i]]+w[i] }*** </center>



## P03:多重背包问题

*问题: 有N种物品和一个容量为V的背包。`每种物品有固定上限n[i]件可用`。第i件物品的大小是c[i]，价值是w[i]。求解哪些物品装入背包可使总价值最大。*

### 基本思路

多重背包问题与完全背包问题很像，只需要把能够取得得件数从V/c[i]缩减到min{V/c[i], n[i]*c[i]}即可。状态转移方程:

<center> ***f[i][v] = max{ f[i-1][v-k\*c[i]]+k\*w[i] | 0<=k<=min{n[i], v/c[i] }*** </center>


### O(VN)的算法

多重背包问题也有O(VN)的方法，这个算法在基本状态转移方程中应用单调队列的方法使每个状态的值可以以均摊O(1)的时间求解。但是"背包问题九讲"没有展开讲解，所以这里也不会展开讲解。



## P04:混合三种背包问题

*问题: 有N种物品和一个容量为V的背包。`有的物品只可以取一次(01背包)，有的物品可以取无限次(完全背包)，有的物品可以取的次数有一个上限(多重背包)`。第i件物品的大小是c[i]，价值是w[i]。求解哪些物品装入背包可使总价值最大。*

### 01背包与完全背包的混合

01背包和完全背包只有一处不通，所以如果只有两类物品，只需要对每个物品应用对应的转移的方程时，根据物品缧绁选用顺序或逆序的循环即可，复杂度为O(VN)。伪代码为:

	for i=1...N
		if 第i件物品属于01背包
			for v=V...0
				f[v]=max{f[v], f[v-c[i]]+w[i]}
		else if 第i件物品属于完全背包
			for v=0...V
				f[v]=max{f[v], f[v-c[i]]+w[i]}

### 再加上多重背包

如果再加上多重背包的问题的话，可以使用O(log n[i])个01背包的方法解决。

	for i=1..N
		if 第i件物品属于01背包
			ZeroOnePack(c[i],w[i])
		else if 第i件物品属于完全背包
			CompletePack(c[i],w[i])
		else if 第i件物品属于多重背包
			MultiplePack(c[i],w[i],n[i])



## P05:二维费用的背包问题

*问题: 有N件物品和一个容量为V、最大负载重量为U的背包。求解哪些物品装入背包可使总价值最大。*

### 算法

费用增加了一维，只需要状态也增加一维即可。设f[i][v][u]表示前i件物品付出代价分别为v和u时可获得的最大价值。a[i]、b[i]分别为两种属性的费用。状态转移方程为:

<center> ***f[i][v][u] = max{ f[i-1][v][u], f[i-1][v-a[i]][u-b[i]]+w[i]}*** </center>

我们再根据题目给定的是01背包问题、完全背包问题还是多重背包问题本类循环更新即可。



## P06:分组的背包问题

*问题: 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。将这些物品划分成若干组，每组中的物品互相冲突，最多选择一件。求解哪些物品装入背包可使总价值最大。*

### 算法

这个问题变成了:是选择本组的一件物品，还是一件物品都不选。也就是f[k][v]表示前k组物品花费v后的最大价值，有:

<center> ***f[k][v] = max{ f[k-1][v], f[k-1][v-c[i]]+w[i] | 物品i属于组k }*** </center>

使用一维数组的伪代码为:

	for 所有的组k
		for v=V...0
			for 所有的i属于k
				f[v]=max{f[v], f[v-c[i]]+w[i]}



## P07:有依赖的背包问题

*问题:背包问题的物品间存在某种"依赖"的关系，如果i依赖于j，表示若选择物品i，则必须选择物品j。为了简化起见，我们假设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖于多件物品。*

### 算法

我们将不依赖别的物品的物品称为"主件"，依赖于某主件的物品称为"附件"。考虑一个主件和它的附件集合，我们称它们为一个物件组。对于一个物件组中的物品，所有费用相同的物品只留一个价值最大的并不影响结果。所以我们可以对主件i的附件集合进行一次01背包，得到费用依次为0...V-c[i]所有这些值时对应的最大价值f'[0...V-c[i]]。那么现在这个主件和它的附件集合相当于V-c[i]+1个物品的物品组，现在可以直接使用P06的算法解决问题了。

### 较一般的问题

更一般的问题时:依赖关系以图论中"多叉树的集合"的形式给出。既是主件的附件也具有自己的附件集合，限制只是每个物品最多只依赖于一个物品(只有一个主件)且不出现循环依赖。

解决这个问题仍然可以用将每个主件及其附件集合转化为物件组的方式。由于附件还有附件，所以必定要先将附件的附件集合转化为物品组，然后用分组的背包问题解出主件及其附件集合对应的附件组中各个费用的附件所对应的价值。

事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了"泛化物品"的思想。P08将会讨论"依赖关系树"每个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子对应的泛化物品之和。



## P08:泛化物品

### 定义

考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。

更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0...V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v)。

这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0...V]，给它费用v，可得到价值h[V]。

一个费用为c价值为w的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为0的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当v被c整除时有h(v)=v/c\*w，其它函数值均为0。如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有h(v)=v/c\*w仅当v被c整除且v/c<=n，其它情况函数值均为0。

一个物品组可以看作一个泛化物品h。对于一个0...V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v)为所有费用为v的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。

### 泛化物品的和

如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0...V的每一个整数v，可以求得费用v分配到h和l中的最大价值f(v)。也即

<center> ***f(v) = max{ h(k)+l(v-k) | 0<=k<=v }*** </center>

可以看到，f也是一个由泛化物品h和l决定的定义域为0...V的函数，也就是说，f是一个由泛化物品h和l决定的泛化物品。

由此可以定义泛化物品的和：h、l都是泛化物品，若泛化物品f满足以上关系式，则称f是h与l的和。这个运算的时间复杂度取决于背包的容量，是O(V^2)。

### 背包问题的泛化物品

一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。

综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。



## P09:背包问题问法的变化

以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法，在这里值得提一下。但是我认为，只要深入理解了求背包问题最大价值的方法，即使问法变化了，也是不难想出算法的。

例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。

还有，如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。

下面说一些变化更大的问法。

### 输出方案

一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。

还是以01背包为例，方程为f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。再用一个数组g[i][v]，设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项（也即f[i][v]=f[i-1][v]），g[i][v]表示采用了方程的后一项。注意这两项分别表示了两种策略:未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写(设最终状态为f[N][V]):

	i=N
	v=V
	while(i>0)
	    if(g[i][v]==0)
			print "未选第i项物品"
		else if(g[i][v]==1)
			print "选了第i项物品"
			v=v-c[i]

另外，采用方程的前一项或后一项也可以在输出方案的过程中根据f[i][v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g[i][v]==0改成f[i][v]==f[i-1][v]，g[i][v]==1改成f[i][v]==f[i-1][v-c[i]]+w[i]也可。

### 求方案总数

对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。

对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是完全背包中的物品，转移方程即为:

<center> ***f[i][v] = sum{ f[i-1][v], f[i][v-c[i]] }*** </center>

初始条件f[0][0]=1。

事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。

### 最优方案的总数

这里的最优方案是指物品总价值最大的方案。以01背包为例。

结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[i][v]意义同前述，g[i][v]表示这个子问题的最优方案的总数，则在求f[i][v]的同时求g[i][v]的伪代码如下：

	for i=1...N
		for v=0...V
		    f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
			g[i][v]=0
			if(f[i][v]==f[i-1][v])
				inc(g[i][v],g[i-1][v])
			if(f[i][v]==f[i-1][v-c[i]]+w[i])
				inc(g[i][v],g[i-1][v-c[i]])

如果你是第一次看到这样的问题，请仔细体会上面的伪代码。

### 求次优解、第K优解

对于求次优解、第K优解类的问题，如果相应的最优解问题能写出状态转移方程、用动态规划解决，那么求次优解往往可以相同的复杂度解决，第K优解则比求最优解的复杂度上多一个系数K。

其基本思想是将每个状态都表示成有序队列，将状态转移方程中的max/min转化成有序队列的合并。这里仍然以01背包为例讲解一下。

首先看01背包求最优解的状态转移方程：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。如果要求第K优解，那么状态f[i][v]就应该是一个大小为K的数组f[i][v][1..K]。其中f[i][v][k]表示前i个物品、背包大小为v时，第k优解的值。“f[i][v]是一个大小为K的数组”这一句，熟悉C语言的同学可能比较好理解，或者也可以简单地理解为在原来的方程中加了一维。显然f[i][v][1..K]这K个数是由大到小排列的，所以我们把它认为是一个有序队列。

然后原方程就可以解释为：f[i][v]这个有序队列是由f[i-1][v]和f[i-1][v-c[i]]+w[i]这两个有序队列合并得到的。有序队列f[i-1][v]即f[i-1][v][1...K]，f[i-1][v-c[i]]+w[i]则理解为在f[i-1][v-c[i]][1...K]的每个数上加上w[i]后得到的有序队列。合并这两个有序队列并将结果的前K项储存到f[i][v][1...K]中的复杂度是O(K)。最后的答案是f[N][V][K]。总的复杂度是O(VNK)。

为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为K的数组，并在这个数组中有序的保存该状态可取到的前K个最优值。那么，对于任两个状态的max运算等价于两个由大到小的有序队列的合并。

另外还要注意题目对于“第K优解”的定义，将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。


---------------------------------------------------------------------------

本文前半部分参考自Tianyi Cui的[背包问题九讲](http://love-oriented.com/pack/#sec9)，后半部分则为摘录。

Permission is granted to copy, distribute and/or modify this document under the terms of the [GNU Free Documentation License](http://www.gnu.org/licenses/fdl.txt), Version 1.2 or any later version published by the Free Software Foundation.
