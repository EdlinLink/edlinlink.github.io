---
layout: post
title:  "String Matching"
date:   2013-09-22 00:00:00
myTag: 	algorithm
---


String Matching
------------------

字符串匹配是一个很常见的问题：

	给定两串字符串T、P，判断P是不是字符串T的子串？

当然逐个匹配的算法是最简单的，但是效率不够快。
我参考的博客文章是mindlee.net的[字符串匹配(String Matching)](http://mindlee.net/2011/11/25/string-matching/)，里面介绍到4种方法，分别是：

1. Rabin-Karp algorithm
2. Knuth-Morris-Pratt algorithm (KMP)
3. Trie
4. Aho-Corasick automation

我这里就只简单谈谈前2种，有兴趣可以google一下第四种AC自动机的相关内容。


Rabin-Karp Algorithm
--------------------
Rabin-Karp算法的思想很简单，就是将T、P这两个数组进行哈希，那么比配起来速度就变快了。
例如：

	T = "1 2 3 4 3 4 5 4 5 7"
	P = "4 3 4 5 4"

我们可以把T和P每5个数位模除13得到一组新的字符串T'，P'

	T' = "6 8 12 8 4 9"
	P' = "8"

其中T':

	6 = 12343 % 13
	8 = 23434 % 13
	12 = 34345 % 13
	8 = 43454 % 13
	4 = 34545 % 13
	9 = 45457 % 13

而P':
	
	8 = 43454 % 13

现在我们只比较T'和P'，P'为T'的子串的唯一可能性就是哈希值一致，即T'的第2位或第4位。哈希值相同可能是T'、P'原来代表的字符串真的完全匹配，或者仅仅是错误命中而已。所以当发现哈希值一样之后，我们还需要回到原来的字符串T、P中进行比较。

现在我们来算一算Rabin-Karp算法的时间复杂度。
假设T有n个字符，P有m个字符
其实我们不需要预先生成T'，我们可以边比较边生成，所以真正的最坏情况下时间为`O((n-m+1)m)`和朴素算法最坏情况下的`O((n-m+1)m)`一样，但是它最坏情况出现的几率比较小，所以平均情况比较好。


Knuth-Morris-Pratt algorithm (KMP)
----------------------------------
KMP算法我只打算讲算法的流程，而具体推导在这里就不啰嗦了，因为我发现在网上很多资料讲太多理论证明，而对于算法流程讲得很少，使读者很难懂。

同样的两个字符串T、P

	T = "b a c b a b a b a a b c b a b"
	P = "a b a b a c a"

对于P我们构造一个记录数组r:

	i		1	2	3	4	5	6	7
	P[i]	a	b	a	b	a	c	a
	r[i]	0	0	1	2	3	0	1

当P匹配T到T的第5位时，P的前5位都是匹配的，但是第6位就不匹配了
	
	T = "b a c b a b a b a 'a' b c b a b"
	P = 		"a b a b a 'c' a"

如果按照朴素算法，P应该只后移1位，然后T、P的指针重新回溯到P开始对齐的位置，继续开始(即从T的第6位重新开始匹配)。
但是KMP算法告诉我们，字符串P向后移动的位置可以是`当前已经匹配位数(5)-当前匹配数对应在记录数组中的数(r[5])`，也即是`5-3=2`，字符串P可以后移2位而不仅仅是1位。

这里我们就讨论一下这个记录数组r是怎么构造的。

	i		1	2	3	4	5	6	7
	P[i]	a	b	a	b	a	c	a
	r[i]	0	0	1	2	3	0	1

记录数组r仅仅和字符串P有关而跟T没有任何关系。

我们默认P[1]对应的r[1]为0，P[1]="a"

P[2]="b"，到P[2]为止，P[2]能与P前缀匹配的字符有0个，r[2]为0，(没看懂这句话不要紧，请继续看)

P[3]="a"，到P[3]为止，P[3]能和P前缀的1个字符P[1]匹配，r[3]为1

P[4]="b"，到P[4]为止，P[3]P[4]能和P前缀的2个字符P[1]P[2]匹配，r[4]为2

P[5]="a"，到P[5]为止，P[3]P[4]P[5]能和P前缀3个字符P[1]P[2]P[3]匹配，r[5]为3

P[6]="c"，到P[6]为止，P[6]不能像P[3]~P[5]一样与P的前缀有匹配，r[6]为0

P[7]="a"，与P的前缀P[1]匹配，r[7]为1

如此一来我们就构造好字符串P对应的记录数组r。

具体为什么P后移的位置可以用`当前匹配位数-当前匹配数对应在记录数组中的数`来计算，大家可以多写几个例子就好明白了。

当然我们还可以补充一点东西，我们可以插入一个0号元素进入数组P和r，使得P、r变成

	i		0	1	2	3	4	5	6	7
	P[i]	''	a	b	a	b	a	c	a
	r[i]	-1	0	0	1	2	3	0	1

P[0]为空，r[0]为-1

这样子KMP的解释就符合我们刚刚给的对于P后移位置的定义了。
当P和T第一个字符就不匹配的时候，当前匹配字符数为0，对应的记录数组中的数为-1，P移动0-(-1)=1个位置。

