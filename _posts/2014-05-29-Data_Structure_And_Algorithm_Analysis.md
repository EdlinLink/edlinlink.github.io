---
layout: post
title:  "《数据结构与算法分析——C语言描述》读书笔记"
date:   2014-05-29 12:00:00
tags:	tech
myTag:	algorithm

---

# 《数据结构与算法分析——C语言描述》读书笔记

---------------------------

1. 最大子序列和问题
2. 中序到后序的转换(表达式转换问题)
3. 二叉树删除操作
4. AVL树
5. 选择问题(使用堆数据结构)
6. 排序问题

---------------------------------------------------------------------------
---------------------------------------------------------------------------

### 1. 最大子序列和问题

算法1:

鸡肋的算法，完全没必要使用到O(N^3)。

``` c++

int MaxSubsequenceSum(const int A[], int N){
	int ThisSum, MaxSum, i, j, k;

	MaxSum=0;
	for(i=0; i<N; i++){
		for(j=i; j<N; j++){
			ThisSum = 0;
			for(k=i; k<=j; k++)
				ThisSum += A[k];

			if(ThisSum > MaxSum)
				MaxSum = ThisSum;
		}
	}
	return MaxSum;
}

```

算法2:

正常算法。

``` c++

int MaxSubsequenceSum(const int A[], int A){
	int ThisSum, MaxSum, i, j;

	MaxSum=0;
	for(i=0; i<N; i++){
		ThisSum = 0;
		for(j=i; j<N; j++){
			ThisSum += A[j];

			if(ThisSum > MaxSum)
				MaxSum = ThisSum;
		}
	}
}

```

算法3:

分治算法。算是比较有特点的解决最大子序列和问题的方法，以前很好见这样解决的。O(N logN)

``` c++ 

static int MaxSubSum(const int A[], int Left, int Right){
	int MaxLeftSum, MaxRightSum;
	int MaxLeftBoderSum, MaxRightBorderSum;
	int LeftBorderSum, RightBorderSum;
	int Center, i;

	if(Left==Right){
		if(A[Left]>0)
			return A[Left];
		else
			return 0;
	}

	Center = (Left+Right) / 2;
	MaxLeftSum = MaxSubSum(A, Left, Center);
	MaxRightSum = MaxSubSum(A, Center+1, Right);

	MaxLeftBorderSum = 0;
	LeftBorderSum = 0;
	for(i=Center; i>=Left; i--){
		LeftBorderSum += A[i];
		if(LeftBorderSum > MaxLeftBorderSum)
			MaxLeftBorderSum = LeftBorderSum;
	}

	MaxRightBorderSum = 0;
	RightBorderSum = 0;
	for(j=Center+1; j<=Right; j++){
		RightBorderSum += A[j];
		if(RightBorderSum > MaxRightBorderSum)
			MaxRightBorderSum = RightBorderSum;
	}

	return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum+RightBorderSum);
}

int MaxSubsequenceSum(const int A[], int N){
	return MaxSubSum(A, 0, N-1);
}

```

算法4:

最优算法。如果在任意时刻，算法都能够对它已经读入的数据给出子序列问题的正确答案，这种特性的算法叫做联机算法(online algorithm)。O(N)

``` c++

int MaxSubsequenceSum(const int A[], int N){
	int ThisSum, MaxSum, j;

	ThisSum = MaxSum = 0;
	for(j=0; j<N; j++){
		ThisSum += A[j];

		if(ThisSum > MaxSum)
			MaxSum = ThisSum;
		else if(ThisSum < 0)
			ThisSum = 0;
	}
	return MaxSum;
}

```


---------------------------------------------------------------------------
---------------------------------------------------------------------------

### 2. 中序到后序的转换(表达式转换问题)

对于如`a + b * c + (d * e + f) * g`，我们想要将式子从它的中序记法(infix)转成它的后序(postfix)或者称为逆波兰式(reverse Polish)记法`a b c * + d e * f + g * +`，因为这样子计算机就可以用O(N)的时间去处理整个式子。

算法思想:

我们需要用一个输出流记录最终输出的东西，我们还需要用一个栈记录操作符的顺序。我们要让高级的操作符先运算，本例子中只有`+`，`*`，`(`，`)`四种操作符。其中`(`的级别最高，`*`次之，`+`最低，当遇到`)`时，将栈中操作符依次弹出，直到将`(`弹出为止。当需要将操作符压入栈中的时候，如果栈中有不低于当前操作符的操作符(比当前操作符更高级或同级)，则将它们弹出(`(`只有遇到`)`才弹出)。

例如在本例子中，算法流程如下:

Stack:	
Output:	a

Stack:	+	
Output:	a

Stack:	+	
Output:	a b

Stack:	+ *  
Output:	a b

Stack:	+ *			
Output:	a b c

Stack:	+ *		
Output:	a b c

此时遇到`+`操作符，而栈中的操作符为更高级的`*`操作符，所以将`*`弹出；接着栈中剩下的操作符是`+`操作符，与当前`+`操作符同级，也弹出；最后将当前`+`操作符压入栈中。

Stack:	+  
Output:	a b c * +

Stack:	+ (		
Output:	a b c * +

Stack:	+ (		
Output:	a b c * + d

Stack:	+ ( *	
Output:	a b c * + d

Stack:	+ ( *	
Output:	a b c * + d e

Stack:	+ ( +	
Output:	a b c * + d e *

Stack:	+ ( +	
Output:	a b c * + d e * f

此时遇到`)`操作符，我们依次将栈中的操作符弹出，直到将`(`操作符弹出为止。`(`，`)`操作符弹出后不进入Output。

Stack:	+  
Output:	a b c * + d e * f +

Stack:	+ *		
Output:	a b c * + d e * f +

Stack:	+ *		
Output:	a b c * + d e * f + g

此时，整个式子读取完毕，将栈中元素依次弹出并放入Output中。

Stack:	
Output:	a b c * + d e * f + g * +

对应的代码可以这里[ReversePolish](https://github.com/EdlinLink/AlgorithmTest/tree/master/ReversePolish)查看。


---------------------------------------------------------------------------
---------------------------------------------------------------------------

### 3. 二叉树删除操作

正如许多数据结构一样，最困难的操作就是删除。一旦发现要被删除的节点，我们就需要考虑几种可能的情况。

(1) 如果节点是叶子节点，那么可以立即删除。  
(2) 如果节点有一个儿子节点，则该节点可以在其父节点调整指针绕过该结点后被删除。  
(3) 如果节点具有两个儿子节点。一般的删除策略是用右子树的最小的数据代替该节点的数据，并递归删除那个节点。因为右子树中的最小的节点不可能有左儿子，所以第二次删除要容易。


<center>!()[../picture/Data_Structure_And_Algorithm_Analysis-1.png]</center>
<center> 图1 二叉树删除节点‘2’ </center>

如果删除的次数不多，通常使用的策略是`懒惰删除(lazy deletion)`: 当一个元素要被删除时，它仍留在树中，而只是做了个被删除的记号。这种做法在有重复关键字时很流行，因为此时记录出现频数的域可以减1。再有，如果被删除的关键字是重新插入的，那么分配一个新单元的开销就可以避免了。


---------------------------------------------------------------------------
---------------------------------------------------------------------------

### 4. AVL树

AVL(Adelson-Velskii and Landis)树是带平衡条件的二叉树，任意节点的两个子树的高度差不超过1。AVL树需要掌握的就是当添加新的节点的时候，如果调整整棵树使得它依然保持平衡。

不平衡情况的出现可能是一下四种情况:

(1) 对a的左儿子的左子树进行一次插入		
(2) 对a的左儿子的右子树进行一次插入		
(3) 对a的右儿子的左子树进行一次插入		
(4) 对a的右儿子的右子树进行一次插入		

#### 单旋转

当遇到情况(1)和情况(4)的时候，需要进行一次旋转，以保持树的平衡。例如当前树的状态如下图所示，插入一个5将导致节点3不平衡，因为5不在3和4(从节点3到达节点5经过的节点)之间，所以只需要一次关于节点3和节点4的单旋转。

				2									2
			.---+---.							.---+---.	
			1		3							1		4
					+---.		--->				.---+---.
						4							3		5
						+---.
							5

此时如果插入一个6，会导致节点2的不平衡，由于6不在2和4之间，所以同样需要一次关于节点2和节点4的单旋转。

				2									4
			.---+---.							.---+---.
			1		4							2		5
				.---+---.		--->		.---+-.		+---.
				3		5					1	  3			6
						+---.
							6
	
此时再插入7，将导致节点5不平衡，因为7不在5和6之间，所以将发生一次关于节点5和节点6的单旋转。

				4									4
			.---+---.							.---+---.
			2		5							2		6
		.---+-.		+---.		--->		.---+-.	  .-+---.
		1	  3			6					1	  3	  5		7
						+---.
							7

#### 双旋转

当遇到情况(2)和情况(3)的时候，单旋转无法解决不平衡的问题。例如在上例中我们插入一个16后再插入一个15。此时会导致节点7的不平衡，因为15在7和16之间，所以就算进行一次单旋转(如下图中间状态)也无法解决不平衡的问题，只能进行一次关于15和16还有7和15的双旋转(右-左旋转)。

				4									4								4
			.---+---.							.---+---.						.---+---.
			2		6							2		6						2		6
		.---+-.	  .-+---.					.---+-.	  .-+---.				.---+-.   .-+---.
		1	  3	  5		7		--->		1	  3	  5		7		--->	1	  3	  5		15
						+---.								+---.						  .-+---.
							16									15						  7		16
						.---+									+---.
						15											16			

此时如果我们插入一个14，将导致节点6的不平衡，由于14在6和15之间，所以需要一次双旋转。首先是关于节点7和15的右旋，接着是关于节点6和7的左旋。

				4									4								4
			.---+---.							.---+---.						.---+---.
			2		6							2		6						2       7
		.---+-.	  .-+---.		--->		.---+-.	  .-+---.		--->	.---+-.   .-+---.
		1	  3	  5		15					1	  3	  5		7				1     3   6     15
					  .-+---.								+---.					 .+	  .-+---.
					  7		16									15					 5	  14	16
					  +-.									  .-+---.
						14									  14	16

最后我们再来一次插入，插入一个13，将导致节点4的不平衡。由于13不在4和7之间，所以只需要一个单旋转就可以解决问题，进行一次关于节点4和7的左旋。

				4									7
			.---+---.							.---+---.
			2		7							4		15
		.---+-.   .-+---.					.---+-.	  .-+---.
		1	  3	  6		15		--->		2	  6	  14	16
				 .+	  .-+---.			.---+.	 .+	 .+	
				 5	  14	16			1	 3	 5	 13
					.-+
					13

#### 总结

由上面的例子可以看出，当插入一个新节点使得原某节点不平衡时，需要考虑的是新节点是否在原某节点和它的子节点之间。若不是，则需要进行原某节点和它子节点的单旋转；若是，则需要进行关于原某节点和原某节点的子节点还有子节点的子节点的双旋转。


---------------------------------------------------------------------------
---------------------------------------------------------------------------

### 5. 选择问题(使用堆数据结构)

对于`堆(heap)`来说，最小堆表示，每一个节点的子节点都要比它小。堆是一棵排满的完全二叉树，底层的元素要从左往右填入。可以使用数组来模拟堆这个数据结构(第0位为空，从第1位开始填)。

添加一个元素，相当于在堆尾添加元素，然后通过比较新元素与它父节点元素是否符合堆的规则，不符合则交换，直至新元素到达它合适的位置，这个过程叫`上滤(percolate up)`。同理，删除操作就是比较删除后节点的两个子节点哪个比较小，将小的移动到空节点位置，直到空节点到达地步，这个时候将堆尾的元素移动到空节点位置，检查是否符合堆的规则。若不符合，则再进行一次上滤即可。

#### 选择问题

选择问题是指给定N个数，求第k个小的数是多少。此类问题的两个简单算法分别是:  
(1) 所有数排序，选择第k个数;
(2) 对前k个数排序，依次将第k+1到N个数一个一个插入序列中，只保留前k个数。如果插入的数比当前的第k小的数大，则抛弃；或者插入数插入到序列中，将原来的第k小的数挤出序列，最后选择第k个数。

此处如果我们使用最小堆这种数据结构，首先根据输入BuildHeap，然后进行k次DeleteMin操作，即每次删除堆顶的元素，因为堆顶的元素为堆中最小的值，所以第k次删除的元素即为所求。

最小堆的代码可以看这里[MinimunHeap](https://github.com/EdlinLink/AlgorithmTest/tree/master/MinimunHeap)。

---------------------------------------------------------------------------
---------------------------------------------------------------------------

### 6. 排序问题

#### 插入排序

相当于对一个排好序的队列插入新的元素但是依然保持其有序性。

``` c++
void InsertionSort(int A[], int N){
	int tmp;
	int i, j;

	for(i=1; i<N; i++){
		tmp = A[i];
		for(j=i; j>0 && A[j-1]>tmp; j--)
			A[j] = A[j-1];
		A[j] = tmp;
	}
}
```

#### 希尔排序

以一个间隔d作为增量，先以间隔d进行插入排序，之后将d减少，重复对序列进行插入排序，直到最后变成间隔减小为1的插入排序。

``` c++
void ShellSort(int A[], int N){
	int i, j, increment;
	int tmp;

	for(increment = N/2; increment > 0; increment /=2){
		for(i=1; i<N; i++){
			tmp = A[i];
			for(j=i; j>increment && A[increment-1]>tmp; j-=increment)
				A[j] = A[j-increment];
			A[j] = tmp;
		}
	}
}
```

#### 快速排序

快速排序的概念其实和归并排序很类似，即选取一个值作为枢纽元，然后将数据分成小于枢纽元的值、枢纽元还有大于枢纽元的值三类，再递归进行。快速排序正如其名，是一种很快的排序算法，速度要比归并排序要快，原因在于它找到合适的值作为枢纽元，将数据分成较为均匀的两份。

随机选取一个值作为枢纽元是可取的方法之一。而取第一个值为枢纽元，则可能遇到最差的状况。一种较好的策略是取第一个、中间和最后的值，取这3个值中间的值作为枢纽元。

#### 桶式排序

虽然很多排序算法的时间复杂度在O(N logN)，但是在某些特殊条件下利用线性时间进行排序也是可能的，一个简单的例子是桶式排序(bucket sort)。输入数据A1到An必须是小于M的正整数组成。那么我们可以使用一个大小为M称为Count的数据去记录数据。首先将数组清空为0。当读入Ai时，Count[Ai]增加1。当读取所有数据后，扫描一次Count数组，打印排序后的表。
